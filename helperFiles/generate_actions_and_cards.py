#!/usr/bin/env python3
"""Generate/extend ID mappings for game actions (attacks, abilities, evolution triggers)
   and cards themselves.

This script scans one or more card JSON files and produces two Python files
under `v2/game/ids/`:

1. `actions.py` – contains ACTION_IDS: Dict[str, int]
   • all attack identifiers (cardId_pokemon_attack_position_target)
   • all ability identifiers (cardId_pokemon_ability_position_target)
   • evolution trigger identifiers (cardId_spot_evolve_basePokemon_into_evolvedPokemon)
   • play basic pokemon identifiers (cardId_spot_playBasicPokemon)
   • retreat identifiers (cardId_pokemon_retreat)

2. `cards.py` – contains CARD_IDS: Dict[str, int] mapping every card `id` to a
   sequential integer.

Indices are persistent: if the target file already exists, its mapping is
imported so existing numbers stay fixed and only *new* keys are appended with
next indices.

Run:
    python helperFiles/generate_actions_and_cards.py [--cards CARD_JSON...]
"""
from __future__ import annotations

import argparse
import importlib.util
import json
import logging
import sys
from pathlib import Path
from typing import Dict, List

sys.path.append(str(Path(__file__).parent.parent))
from v2.game.ids.action_id_generation import ActionIdGenerator

# ---------------------------------------------------------------------------
# helpers
# ---------------------------------------------------------------------------

def load_existing_mapping(py_path: Path, var_name: str) -> Dict[str, int]:
    """Load existing ID mapping from a Python file, if it exists."""
    if not py_path.exists():
        return {}

    spec = importlib.util.spec_from_file_location("existing", py_path)
    if not spec or not spec.loader:
        return {}

    module = importlib.util.module_from_spec(spec)
    sys.modules["existing"] = module
    spec.loader.exec_module(module)
    return getattr(module, var_name, {})  # type: ignore[return-value]

# ---------------------------------------------------------------------------
# mapping builders
# ---------------------------------------------------------------------------

def build_actions_mapping(cards: List[dict], existing: Dict[str, int]) -> Dict[str, int]:
    """Build mapping of action IDs to sequential integers."""
    mapping = existing.copy()
    next_id = max(mapping.values()) + 1 if mapping else 0

    def add(key: str):
        nonlocal next_id
        if key not in mapping:
            mapping[key] = next_id
            next_id += 1

    # Process in sorted order for deterministic output
    for card in sorted(cards, key=lambda c: c["id"]):
        try:
            # Add play basic pokemon IDs
            for action_id in ActionIdGenerator.get_all_action_ids(card):
                add(action_id)
        except Exception as e:
            logging.error(f"⚠️ Error processing card {card.get('name', card.get('id', 'Unknown'))}: {str(e)}")
            # Print the full error for debugging
            import traceback
            logging.debug(traceback.format_exc())

    return mapping

def build_card_mapping(cards: List[dict], existing: Dict[str, int]) -> Dict[str, int]:
    """Build mapping of card IDs to sequential integers."""
    mapping = existing.copy()
    next_id = max(mapping.values()) + 1 if mapping else 0

    for card in sorted(cards, key=lambda c: c["id"]):
        if card["id"] not in mapping:
            mapping[card["id"]] = next_id
            next_id += 1

    return mapping

# ---------------------------------------------------------------------------
# file writers
# ---------------------------------------------------------------------------

def write_mapping(mapping: Dict[str, int], py_path: Path, var_name: str):
    """Write ID mapping to a Python file."""
    content = [
        "from typing import Dict",
        "",
        "# Auto-generated by helperFiles/generate_actions_and_cards.py",
        "# DO NOT EDIT MANUALLY.",
        "",
        f"{var_name}: Dict[str, int] = {{",
    ]

    # Write entries in sorted order for deterministic output
    for key in sorted(mapping.keys()):
        content.append(f"    {key!r}: {mapping[key]},")

    content.extend(["}", ""])

    py_path.write_text("\n".join(content))
    logging.info(f"[OK] Wrote {len(mapping)} entries -> {py_path}")

# ---------------------------------------------------------------------------
# main entry
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--cards",
        type=Path,
        nargs="+",
        default=[Path("v2/assets/cards/a1-genetic-apex.json")],
        help="Card JSON files to process",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Enable debug logging"
    )
    args = parser.parse_args()

    # Configure logging
    log_level = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(format="%(message)s", level=log_level)

    # Load and merge all card JSONs
    cards = []
    for path in args.cards:
        cards.extend(json.loads(path.read_text()))
    logging.info(f"[INFO] Loaded {len(cards)} cards from {len(args.cards)} file(s)")

    # Generate action ID mapping
    actions_py = Path("v2/game/ids/actions.py")
    actions_py.parent.mkdir(parents=True, exist_ok=True)
    existing = load_existing_mapping(actions_py, "ACTION_IDS")
    mapping = build_actions_mapping(cards, existing)
    write_mapping(mapping, actions_py, "ACTION_IDS")

    # Generate card ID mapping
    cards_py = Path("v2/game/ids/cards.py")
    cards_py.parent.mkdir(parents=True, exist_ok=True)
    existing = load_existing_mapping(cards_py, "CARD_IDS")
    mapping = build_card_mapping(cards, existing)
    write_mapping(mapping, cards_py, "CARD_IDS")

if __name__ == "__main__":
    main() 